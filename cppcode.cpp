#include <random>
#include <iostream>
#include <thrust/host_vector.h>
#include "armadillo"
#include <lapacke.h>

using namespace arma;
using namespace std;

void mynormalcpp(double* output, double mmu, double ssigma, int n, unsigned seed) {
	
	// Specify engine and distribution
	std::default_random_engine generator(seed);
	std::normal_distribution<double> distribution(mmu,ssigma);

	// Actually generate random numbers
	for (int i=0; i<n; i++) {	
		output[i] = distribution(generator);
	};
	
};

void myuniformcpp(double* output, int n, unsigned seed)
{
	std::default_random_engine generator(seed);
    std::uniform_real_distribution<double> d(0,1);
    
	for (int i=0; i<n; i++) {
		output[i] = d(generator);
	};
};

void myexponentialcpp(double* output, int n, unsigned seed)
{
	std::default_random_engine generator(seed);
    std::exponential_distribution<double> d(1.0);
    
	for (int i=0; i<n; i++) {
		output[i] = d(generator);
	};
};

int chebyroots_cpp(const int p, double* roots) {
    for (int i=0; i<p; i++) {
        double stuff = p - 0.5 - 1*i;
        roots[i] = cos(M_PI*(stuff)/(p));
    };

    // Account for the fact that cos(pi/2) is not exactly zeros
    if (p%2) {
        roots[(p-1)/2] = 0;
    };
    return 0;
};

void fromchebydomain(double lb, double ub, int p, double* ptr) {
	for (int i=0; i<p; i++) {
		ptr[i] = lb + (ptr[i]+1)/(2)*(ub-lb);	
	};
};

double mynormalcdf(double mean, double variance, double x) {
	return 0.5*( 1+erf( (x-mean)/sqrt(2*variance) ) );
};

// Create a equal-distance grid
void linspace(double min, double max, int N, double* grid) {
	double step  = (max-min)/(N-1);
	for (int i = 0; i < N; i++) {
		grid[i] = min + step*i;
	};
};

// Create a grid based on chebyshev roots
void chebyspace(double min, double max, int N, double* grid) {
	chebyroots_cpp(N, grid);
	fromchebydomain(min, max, N, grid);
};

// Define a type of function pointer
typedef void (*gridgen_fptr)(double, double, int, double*);

// Declare ind2sub here. Code is generated by cuda_helpers.h and compiled by nvcc though. The linker will find the right machine code for me. Now this code is dependent on cuda_helpers.h
void ind2sub(int, int*, int, int*);

// This function follows notation from Tauchen 1986 the vector case using Armadillo
void tauchen_vec(int M, int N, int m, double* A_ptr, double* Ssigma_e_ptr, double* Z_ptr, double* P_ptr, gridgen_fptr gridgen) {
// Purpose:		Discretize y_t = A*y_t-1 + epsilon_t, where var(epsilon_t)=Ssigma_e
// 				y_t is an M by 1 vector
//
// Input:		M = # of shocks
// 				N = # of grid points for each shock
// 				m = # of s.d. away from mean should we use as bounds 
// 				A = Autocorrelation matrix, stored in array 
// 				Ssigma_e = variance-convariance matrix, stored in array
//
// Output:		Z = Vectorized N by M matrix where each column stores grids
// 				P = Vectorized transition matrix (N^M by N^M)
	
	// 1. Read in matrices
	mat A(M,M);
	mat Ssigma_e(M,M);
	for (int i=0; i < M*M; i++) {
		int i_c = i/M;
		int i_r = i - i_c*M;
		A(i_r,i_c) = A_ptr[i];
		Ssigma_e(i_r,i_c) = Ssigma_e_ptr[i];
	};

	// 2. Find Variance Matrix for y
	vec Ssigma_e_vec = vectorise(Ssigma_e);
	vec Ssigma_y_vec = inv( eye(M*M,M*M) - kron(A,A) ) * Ssigma_e_vec;
	mat Ssigma_y = reshape(Ssigma_y_vec,M,M);
	A.print("Autocorr Matrix:");
	Ssigma_e.print("Var-Cove Matrix of Innovations:");
	Ssigma_y.print("Var-Cov Matrix of Observables:");

	// 3. Create Grids. Assuming same # of grid points for each shock
	mat grids(M,N); // collects grid points here
	for (int i_shock=0; i_shock<M; i_shock++) {
		double minshock = -m*sqrt(Ssigma_y(i_shock,i_shock));
		double maxshock = +m*sqrt(Ssigma_y(i_shock,i_shock));
		vec temp_grid(N);
		gridgen(minshock,maxshock,N,temp_grid.memptr());
		grids.row(i_shock) = trans(temp_grid);
	};
	grids.print("Grids:");

	// 4. Compute Transition Matrix
	mat P(pow(N,M),pow(N,M));
	cube h(M,pow(N,M),N);
	Col<int> sizes(M); sizes.fill(N);
	Col<int> subs(M);
	vec lag_y(M);
	for (int j=0; j<pow(N,M); j++) {
		// First find the conditional mean
		ind2sub(M, sizes.memptr(), j, subs.memptr());
		for (int i_shock=0; i_shock<M; i_shock++) lag_y(i_shock) = grids(i_shock,subs(i_shock));
		vec mmu = A*lag_y;

		// Fill the h cube
		double w_right, w_left;
		for (int i=0; i<M; i++) {
			for (int l=0; l<N; l++) {
				if (l==0) {
					w_right = grids(i,l+1) - grids(i,l);
					h(i,j,l) = mynormalcdf(0,Ssigma_e(i,i),grids(i,l)-mmu(i)+w_right/2);
				}
			   	else if (l==N-1) {
					w_left = grids(i,l) - grids(i,l-1);
					h(i,j,l) = 1 - mynormalcdf(0,Ssigma_e(i,i),grids(i,l)-mmu(i)-w_left/2);
				}
			   	else {
					w_left = grids(i,l) - grids(i,l-1);
					w_right = grids(i,l+1) - grids(i,l);
					h(i,j,l) = mynormalcdf(0,Ssigma_e(i,i),grids(i,l)-mmu(i)+w_right/2)
							 - mynormalcdf(0,Ssigma_e(i,i),grids(i,l)-mmu(i)-w_left/2);
				};
			};
		};
	};
	for (int j=0; j<pow(N,M); j++) {
		for (int k=0; k<pow(N,M); k++) {
			ind2sub(M, sizes.memptr(), k, subs.memptr());
			double cumprod = 1;
			for (int i=0; i<M; i++) {
				cumprod *= h(i,j,subs(i));
			};
			P(j,k) = cumprod;
		};
	};
	vec rowsum = sum(P,1);
	
	// 5. Check Accuracy
	arma_rng::set_seed(51709394);
	int T = 1e3;
	mat eps(M,T);
	for (int i_shock=0; i_shock<M; i_shock++) { 
		eps(i_shock,span::all) = trans(sqrt(Ssigma_e(i_shock,i_shock))*randn<vec>(T));
	};
	mat sim_y = zeros<mat>(M,T);
	for (int t=0; t<T-1; t++) {
		sim_y(span::all,t+1) = A*sim_y(span::all,t) + eps(span::all,t+1);
	};
	mat Z = sim_y(span::all,span(0,T-2));
	mat Y = sim_y(span::all,span(1,T-1));
	mat B(M,M);
	B = Y*trans(Z)*inv(Z*trans(Z)); //Multivariate Regression, formulas from Wikipedia
	B.print("Discrete Autocorr Matrix:");
	mat C = cov(trans(sim_y));
	C.print("Discrete Var-Cov Matrix of Observables: ");

	// 6. Output Results
	mat Z_out = trans(grids);
	double *Z_out_ptr = Z_out.memptr();
	for (int index=0; index<N*M; index++) {
		Z_ptr[index] = Z_out_ptr[index];
	};
	double* P_out_ptr = P.memptr();
	for (int index=0; index<pow(N,M)*pow(N,M); index++) {
		P_ptr[index] = P_out_ptr[index]; 
	};
};

void findprojector(double* X_ptr, int nrows, int ncols, double * P_ptr) {
	mat X(X_ptr, nrows, ncols, false, false);
	mat XprimeX = diagmat(trans(X)*X);
	// XprimeX.print("X'X=");
	mat P = inv(XprimeX)*trans(X);
	// P.print("Projector=");
	
	for (int i=0; i<nrows*ncols; i++) {
		P_ptr[i] = P.memptr()[i];
	};

};

lapack_logical qzdivide(const double* real_alpha, const double* imagine_alpha, const double* real_beta) {
	// Generalised eigenvalues are a/c + b/c*i
	double a = * real_alpha;
	double b = * imagine_alpha;
	double c = * real_beta;

	// Determined whether eigenvalues are within unit circle, assuming not all a,b,c are zeros.
	// We want the >1 on upper left, because we will invert it later.
	if (c==0) {
		return true;
	} else if (sqrt( a*a/(c*c) + b*b/(c*c)  )<1) {
		return false;
	} else {
		return true;
	};
};

int qzdecomp (mat &A, mat &B, mat &Q, mat &Z) {
// Purpose:
// 	Compute QZ decomposition for a pair nonsymmetric matrice (A,B).
// 	A = Q*S*Z', B = Q*T*Z'
// 	where S, T is stored in A, B when done.
// 	The decomposition is ordered such that explosive eigenvalues are placed in lower right of inv(S)*T;
// 	Returns the number of unstable roots

	// Preparations
	int n_selected;
	vec alphar(A.n_rows);
	vec alphai(A.n_rows);
	vec beta(B.n_rows);
	lapack_int info;	// stores the exit information 
	mat A_old = A;
	mat B_old = B;
	LAPACK_D_SELECT3 selctg = qzdivide; 

	// Call LAPACK
	info = LAPACKE_dgges(
			LAPACK_COL_MAJOR,	// indicate we use column major
			'V',				// ... and compute left schur vector 
			'V',				// ... and compute right schur vector
			'S',				// ... and sort eigenvalues
			selctg,				// with this func to divide eigenvalues
			A.n_rows,			// # of rows in A
			A.memptr(),			// array that stores A
			A.n_rows,			// leading dimension of A (rows)
			B.memptr(),			// array that stores B
			B.n_rows,			// rows of B
			&n_selected,		// output the # of eigenvalues 
			alphar.memptr(),	// stores aux vectors
			alphai.memptr(),	// stores aux vector
			beta.memptr(),		// stores aux vector
			Q.memptr(),			// stores Q
			A.n_rows,
			Z.memptr(),
			B.n_rows
			);
	
	// Transpose Q and Z, consistent with Juan's notation.
	Q = trans(Q);
	Z = trans(Z);

	// Print and See
	A.print("S = ");
	B.print("T = ");
	Q.print("Q = ");
	Z.print("Z = ");

	// Check accuray
	mat Atilde = trans(Q)*A*Z;
	Atilde.print("Atilde = ");
	mat wewant = inv(A)*B;
	wewant.print("We want this matrix on RHS:");
	
	// Compute the number of unstable roots (in lower right of inv(S)*T)
	return A.n_rows - n_selected;
};

void test() {
	mat A(3,3);
	A << 4 << 2 << 9 << endr
	  << 1 << 2 << 7 << endr
	  << 9 << 3 << 0 << endr;
	mat B(3,3);
	B << 7 << 6 << 8 << endr
	  << 2 << 5 << 1 << endr
	  << 8 << 4 << 1 << endr;
	mat Q(3,3);
	mat Z(3,3);
	qzdecomp(A,B,Q,Z);
};

void linearQZ(double* A_ptr, double* B_ptr, double* C_ptr, double* rrho_ptr, int n, int n_jump, int n_shock, double* Pphi_ptr) {
// Purpose: (Following Juan's notation)
// 	Solves any linear rational expectation model in the form of:
// 	A* E_t y_t+1 = B* y_t + C * z_t and
// 	z_t = rrho* z_t-1 + G * epsilon_t
// 	y_t is the n-by-1 vector of endogenuous variables which contains n_predeter
// 	predetermined (jump) variables. A, B, rrho, and C are n-by-n

	// Wrap armadillo mat around raw arrays
	mat A(A_ptr,n,n,false,true) ;
	mat B(B_ptr,n,n,false,true) ;
	mat C(C_ptr,n,n_shock,false,true) ;
	mat rrho(rrho_ptr,n_shock,n_shock,false,true) ;
	
	// Call QZ decomposition
	mat Llambda = A;
	mat Oomega = B;
	mat Q(n,n);
	mat Z(n,n);
	int n_unstable = qzdecomp(Llambda,Oomega,Q,Z);

	// Check counting rule
	if (n_unstable > n_jump) {
		printf("There is %i unstables roots but %i jump variables => no solution.\n", n_unstable, n_jump);
	} else if (n_unstable < n_jump) {
		printf("There is %i unstables roots but %i jump variables => infinitely many solutions.\n", n_unstable, n_jump);
	} else {
		printf("There is %i unstables roots but %i jump variables => unique solution.\n", n_unstable, n_jump);
	};

	// Find solution.
	mat Ggamma = inv(Llambda)*Oomega;
	mat Ppsi = inv(Llambda)*Q*C;
	mat Ggamma11 = Ggamma(span(0,n-n_jump-1),span(0,n-n_jump-1));
	mat Ggamma12 = Ggamma(span(0,n-n_jump-1),span(n-n_jump,n-1));
	mat Ggamma21 = Ggamma(span(n-n_jump,n-1),span(0,n-n_jump-1));
	mat Ggamma22 = Ggamma(span(n-n_jump,n-1),span(n-n_jump,n-1));
	mat Z11 = Z(span(0,n-n_jump-1),span(0,n-n_jump-1));
	mat Z12 = Z(span(0,n-n_jump-1),span(n-n_jump,n-1));
	mat Z21 = Z(span(n-n_jump,n-1),span(0,n-n_jump-1));
	mat Z22 = Z(span(n-n_jump,n-1),span(n-n_jump,n-1));
	mat Ppsi1 = Ppsi(span(0,n-n_jump-1),span::all);
	mat Ppsi2 = Ppsi(span(n-n_jump,n-1),span::all);
	vec M_vec = inv( eye(n_shock*n_jump,n_shock*n_jump)-kron(trans(rrho),inv(Ggamma22))  )*vectorise(Ppsi2);
	mat M = reshape(M_vec,n_jump,n_shock);
	mat Pphi_cstar_z = -inv(Ggamma22)*M;	// Finally get c*_t = Pphi_cstrt_z * z_t
	mat Pphi_c_k = -inv(Z22)*Z21;
	mat Pphi_c_z = inv(Z22)*Pphi_cstar_z;
	mat Pphi_k_k = inv(Z11+Z12*Pphi_c_k)*Ggamma11*(Z11+Z12*Pphi_c_k);
	mat Pphi_k_z = inv(Z11+Z12*Pphi_c_k)*(Ggamma11*Z12*Pphi_c_z+Ggamma12*Pphi_cstar_z+Ppsi1-Z12*Pphi_c_z*rrho);
	mat Pphi = join_cols( join_rows(Pphi_k_k,Pphi_k_z), join_rows(Pphi_c_k,Pphi_c_z)  );

	// Output Pphi, the solution.
	for (int i = 0; i < n*(n-n_jump+n_shock); i++) {
		Pphi_ptr[i] = Pphi.memptr()[i];
	};

};
